1. 析构函数能否设置成私有？

当我们规定类只能在堆上分配内存时，就可以将析构函数声明为私有的。

class alloc

{

public:

    alloc():

private:

   ~alloc();

};

 

如果在栈上分配空间，类在离开作用域时会调用析构函数释放空间，此时无法调用私有的析构函数。

如果在堆上分配空间，只有在delete时才会调用析构函数。

 

可以添加一个destroy()函数来释放,从而解决不能在析构函数中添加delete的问题。

class alloc

{

public:

    alloc():

　destroy(){ delete this;} 　

private:

   ~alloc();
   
   
 }；
 
 2.构造函数能否设置成私有？
 可以，参考单例模式


3. 为什么构造函数不能为虚函数？
    虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。
 
4. 为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？
    首先析构函数可以为虚函数，而且当要使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。
    举例说明：
    子类B继承自基类A；A *p = new B; delete p;
 　1） 此时，如果类A的析构函数不是虚函数，那么delete p；将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。
     2） 如果类A的析构函数是虚函数，delete p; 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。
    补充： B *p = new B; delete p;时也是先调用B的析构函数，再调用A的析构函数。
