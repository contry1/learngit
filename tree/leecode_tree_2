int flag = 1;
int treeis_same(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)

		return 0;
	else if (p == NULL&&q == NULL)
		return -1;//?

	int f1 = treeis_same(p->left, q->left);
	int f2 = treeis_same(p->right, q->right);

	if (p->val != q->val)
	{
		cout << "value p1: " << p->val << endl;
		cout << "value q1: " << q->val << endl;
		flag = 0;
		return 0;
	}
	
	else
	{
		cout << "value p: " << p->val << endl;
		cout << "value q: " << q->val << endl;
		//return 1;
	}
	cout << "f1: f2:    " << f1<<f2 << endl;
//	return flag;

}



int iso(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)
		return 0;
	else if (p == NULL&&q == NULL)
		return 1;//?
	//iso(p->left,q->right);
	//iso(p->right, q->left);

	if (p->val != q->val)
		return 0;
	else
	{
		return iso(p->left, q->right)&& iso(p->right, q->left);
	}
		//return 1;
}
int treeis_iso(tree * node)
{
	if (root == NULL)
		return 1；
	if (root && root->left == NULL && root->right == NULL)
		return 1；
	return iso(node->left,node->right);
}


bool path(struct TreeNode* left, struct TreeNode* right,int sum)
{
    if(left == NULL || right == NULL)
        return 0;
    if(left->val + right->val == sum)
        return 1;
    return path();
}

bool hasPathSum(struct TreeNode* root, int sum){
    if(root == NULL)
        return 0;
    if(root && root->left == NULL && root->right== NULL && root->val == sum)
        return 1;
    return path(root->left,root->right,sum);
}



//REVERSE  LINK
link2* q;
link2*  re(link2* node)
{

	if (node->next == NULL)
	{
	
		q = node;
		return node;
	}
	
	//if (node == NULL)
	//	return NULL;
	cout << node->val << endl;

	link2* p = node->next;
	
	cout << "p0:" << p->val << endl;
//	cout << "po:"  << endl;
	re(node->next);
	//p = node->next;
	p->next = node;
	cout << "next:" << p->next->val << endl;
	node->next = NULL;
	p = node;
	cout << "p:"<<node->val << endl;


	return q;
}

//jainfa  total path

int oath(tree * root,int sum)
{

	if (root == NULL)
	{
		return 0;
	}

	if (root->left == NULL && root->right == NULL)
	{
		if (root->val == sum)
			return 1;
		else
			return 0;
	}

	return oath(root->left,sum-root->val) || oath(root->right, sum - root->val);

}



tree * inver(tree * root)
{
	if (root == NULL)
	{
		return NULL;
	}
	tree * p = root->left;
	root->left = root->right;
	root->right = p;

	inver(root->left);
	inver(root->right);

	return root;
}
