int flag = 1;
int treeis_same(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)

		return 0;
	else if (p == NULL&&q == NULL)
		return -1;//?

	int f1 = treeis_same(p->left, q->left);
	int f2 = treeis_same(p->right, q->right);

	if (p->val != q->val)
	{
		cout << "value p1: " << p->val << endl;
		cout << "value q1: " << q->val << endl;
		flag = 0;
		return 0;
	}
	
	else
	{
		cout << "value p: " << p->val << endl;
		cout << "value q: " << q->val << endl;
		//return 1;
	}
	cout << "f1: f2:    " << f1<<f2 << endl;
//	return flag;

}



int iso(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)
		return 0;
	else if (p == NULL&&q == NULL)
		return 1;//?
	//iso(p->left,q->right);
	//iso(p->right, q->left);

	if (p->val != q->val)
		return 0;
	else
	{
		return iso(p->left, q->right)&& iso(p->right, q->left);
	}
		//return 1;
}
int treeis_iso(tree * node)
{
	if (root == NULL)
		return 1；
	if (root && root->left == NULL && root->right == NULL)
		return 1；
	return iso(node->left,node->right);
}


bool path(struct TreeNode* left, struct TreeNode* right,int sum)
{
    if(left == NULL || right == NULL)
        return 0;
    if(left->val + right->val == sum)
        return 1;
    return path();
}

bool hasPathSum(struct TreeNode* root, int sum){
    if(root == NULL)
        return 0;
    if(root && root->left == NULL && root->right== NULL && root->val == sum)
        return 1;
    return path(root->left,root->right,sum);
}
