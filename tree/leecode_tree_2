int flag = 1;
int treeis_same(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)

		return 0;
	else if (p == NULL&&q == NULL)
		return -1;//?

	int f1 = treeis_same(p->left, q->left);
	int f2 = treeis_same(p->right, q->right);

	if (p->val != q->val)
	{
		cout << "value p1: " << p->val << endl;
		cout << "value q1: " << q->val << endl;
		flag = 0;
		return 0;
	}
	
	else
	{
		cout << "value p: " << p->val << endl;
		cout << "value q: " << q->val << endl;
		//return 1;
	}
	cout << "f1: f2:    " << f1<<f2 << endl;
//	return flag;

}



int iso(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)
		return 0;
	else if (p == NULL&&q == NULL)
		return 1;//?
	//iso(p->left,q->right);
	//iso(p->right, q->left);

	if (p->val != q->val)
		return 0;
	else
	{
		return iso(p->left, q->right)&& iso(p->right, q->left);
	}
		//return 1;
}
int treeis_iso(tree * node)
{
	if (root == NULL)
		return 1；
	if (root && root->left == NULL && root->right == NULL)
		return 1；
	return iso(node->left,node->right);
}




bool path(struct TreeNode* left, struct TreeNode* right,int sum)
{
    if(left == NULL || right == NULL)
        return 0;
    if(left->val + right->val == sum)
        return 1;
    return path();
}

bool hasPathSum(struct TreeNode* root, int sum){
    if(root == NULL)
        return 0;
    if(root && root->left == NULL && root->right== NULL && root->val == sum)
        return 1;
    return path(root->left,root->right,sum);
}



//REVERSE  LINK
link2* q;
link2*  re(link2* node)
{

	if (node->next == NULL)
	{
	
		q = node;
		return node;
	}
	
	//if (node == NULL)
	//	return NULL;
	cout << node->val << endl;

	link2* p = node->next;
	
	cout << "p0:" << p->val << endl;
//	cout << "po:"  << endl;
	re(node->next);
	//p = node->next;
	p->next = node;
	cout << "next:" << p->next->val << endl;
	node->next = NULL;
	p = node;
	cout << "p:"<<node->val << endl;


	return q;
}

//jainfa  total path

int oath(tree * root,int sum)
{

	if (root == NULL)
	{
		return 0;
	}

	if (root->left == NULL && root->right == NULL)
	{
		if (root->val == sum)
			return 1;
		else
			return 0;
	}

	return oath(root->left,sum-root->val) || oath(root->right, sum - root->val);

}



tree * inver(tree * root)
{
	if (root == NULL)
	{
		return NULL;
	}
	tree * p = root->left;
	root->left = root->right;
	root->right = p;

	inver(root->left);
	inver(root->right);

	return root;
}

//最近龚工祖先
tree * ans(tree * root, tree *p, tree * q)
{
	if (root == NULL)
	{
		return NULL;
	}
	
	if (p->val <= root->val && q->val <= root->val)
	{
		return ans(root->left, p, q);
	}
	else if (p->val <= root->val && q->val <= root->val)
	{
		return ans(root->right, p, q);
	}
	else
	{
		return root;
	}


}


快乐数
int fun(int n)
{

loop:
	int index = 1;
	while (n / 10 != 0)
	{
		index++;
		n = n / 10;
	}

	int  i = 0;
	int num[1000];
	for (i = 0; i <index; i++)
	{
		num[i] = n % 10;
		n = n / 10;
	}

	int t1 = 0;
	for (i = 0; i < index; i++)
	{
		t1 += num[i] * num[i];
	}

	if (t1 == 1)
		return  1;
	else
	{
		n = t1;
		goto loop;
	}

}
