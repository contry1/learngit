int flag = 1;
int treeis_same(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)

		return 0;
	else if (p == NULL&&q == NULL)
		return -1;//?

	int f1 = treeis_same(p->left, q->left);
	int f2 = treeis_same(p->right, q->right);

	if (p->val != q->val)
	{
		cout << "value p1: " << p->val << endl;
		cout << "value q1: " << q->val << endl;
		flag = 0;
		return 0;
	}
	
	else
	{
		cout << "value p: " << p->val << endl;
		cout << "value q: " << q->val << endl;
		//return 1;
	}
	cout << "f1: f2:    " << f1<<f2 << endl;
//	return flag;

}



int iso(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)
		return 0;
	else if (p == NULL&&q == NULL)
		return 1;//?
	//iso(p->left,q->right);
	//iso(p->right, q->left);

	if (p->val != q->val)
		return 0;
	else
	{
		return iso(p->left, q->right)&& iso(p->right, q->left);
	}
		//return 1;
}
int treeis_iso(tree * node)
{
	if (root == NULL)
		return 1；
	if (root && root->left == NULL && root->right == NULL)
		return 1；
	return iso(node->left,node->right);
}




bool path(struct TreeNode* left, struct TreeNode* right,int sum)
{
    if(left == NULL || right == NULL)
        return 0;
    if(left->val + right->val == sum)
        return 1;
    return path();
}

bool hasPathSum(struct TreeNode* root, int sum){
    if(root == NULL)
        return 0;
    if(root && root->left == NULL && root->right== NULL && root->val == sum)
        return 1;
    return path(root->left,root->right,sum);
}



//REVERSE  LINK
link2* q;
link2*  re(link2* node)
{

	if (node->next == NULL)
	{
	
		q = node;
		return node;
	}
	
	//if (node == NULL)
	//	return NULL;
	cout << node->val << endl;

	link2* p = node->next;
	
	cout << "p0:" << p->val << endl;
//	cout << "po:"  << endl;
	re(node->next);
	//p = node->next;
	p->next = node;
	cout << "next:" << p->next->val << endl;
	node->next = NULL;
	p = node;
	cout << "p:"<<node->val << endl;


	return q;
}

//jainfa  total path

int oath(tree * root,int sum)
{

	if (root == NULL)
	{
		return 0;
	}

	if (root->left == NULL && root->right == NULL)
	{
		if (root->val == sum)
			return 1;
		else
			return 0;
	}

	return oath(root->left,sum-root->val) || oath(root->right, sum - root->val);

}



tree * inver(tree * root)
{
	if (root == NULL)
	{
		return NULL;
	}
	tree * p = root->left;
	root->left = root->right;
	root->right = p;

	inver(root->left);
	inver(root->right);

	return root;
}

//最近龚工祖先
tree * ans(tree * root, tree *p, tree * q)
{
	if (root == NULL)
	{
		return NULL;
	}
	
	if (p->val <= root->val && q->val <= root->val)
	{
		return ans(root->left, p, q);
	}
	else if (p->val <= root->val && q->val <= root->val)
	{
		return ans(root->right, p, q);
	}
	else
	{
		return root;
	}


}


快乐数
int fun(int n)
{

loop:
	int index = 1;
	while (n / 10 != 0)
	{
		index++;
		n = n / 10;
	}

	int  i = 0;
	int num[1000];
	for (i = 0; i <index; i++)
	{
		num[i] = n % 10;
		n = n / 10;
	}

	int t1 = 0;
	for (i = 0; i < index; i++)
	{
		t1 += num[i] * num[i];
	}

	if (t1 == 1)
		return  1;
	else
	{
		n = t1;
		goto loop;
	}

}

int fun(int n)
{
	int index = 0;
	int t[1000] = {0};
	int j = 0;
loop:
	index = 1;
	int back = n;
	int total = n;
	while (total / 10 != 0)
	{
		index++;
		total = total / 10;
	}

	int  i = 0;
	int num[1000];
	for (i = 0; i <index; i++)
	{
		num[i] = back % 10;
		back = back / 10;
	}

	int t1 = 0;
	for (i = 0; i < index; i++)
	{
		t1 += num[i] * num[i];
		cout << t1 << endl;
	}
	t[j++] = t1;
	cout <<"hh"<< t1 << endl;
	if (t1 == 1)
	{
		return  1;
	}
	
	else
	{
		int m = 0;
		for (m = 0; m < j - 1; m++)
		{
			cout << "tm:" << t[m] << endl;
			if (t[m] == t1)
				return 0;
		}
	
		n = t1;
		cout << "n:" << t1 << endl;
		goto loop;
	}

}


、、合并来拿吧
link*  combine(link* node1, link* node2)
{
	link* root;
	if (node1 == NULL && node2 == NULL)
		return NULL;
	if (node1 == NULL && node2)
	{
		cout << "node22:" << node2->val << endl;
		return node2;
	}
		
	if (node2 == NULL && node1)
	{
		cout << "node11:" << node1->val << endl;
		return  node1;
	}
	
	if (node1->val <= node2->val)
	{
		root = node1;
		cout << "node1:" << node1->val << endl;
		root->next =  combine(node1->next, node2);
	}
	else
	{
		root = node2;
		cout << "node2:" << node2->val << endl;
	//	node1->next = node2;
		root->next = combine(node1 , node2->next);
	}


	

	return root;
	

}


link*  del(link* node, int n)
{
	link*  prev = node;
	link*  last = node;
	link*  del_n = node;
	while (n)
	{
		last = last->next;
		n--;
	}

	while (last)
	{
		del_n = prev;
		last = last->next;
		prev = prev->next;
	}
	link*  p = prev;
	del_n->next = p->next;
	free(p);
	return node;
}
