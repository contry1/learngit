//地柜
void insert_tree_demo(b_tree * bt, int  value)
{
	int left = 0;
	int right = 0;
	std::cout << "please input new node value:" << value << endl;
	if (!bt)
	{
		bt = create_tree(value);
		return ;
	}
	if (bt->value == value)
		return ;
	else if (bt->value > value)
	{
		if (bt->left == NULL)
		{
			bt->left = create_tree(value);
			return ;
		}
		else
		{
			insert_tree3(bt->left, value);
		}

	}
	else if (bt->value < value)
	{
		if (bt->right == NULL)
		{
			bt->right = create_tree(value);
			return ;
		}
		else
		{
		
			 insert_tree3(bt->right, value);
		}

	}


}

//第二种地柜
void insert_tree_demo2(b_tree * bt, int  value)
{
	
	std::cout << "please input new node value:" << value << endl;
	if (!bt)
	{
		bt = create_tree(value);
		return;
	}
	if (bt->value == value)
		return;
	if (bt->value > value&& bt->left == NULL)
	{
		bt->left = create_tree(value);
		return;
	}
	if (bt->value < value&& bt->right == NULL)
	{
		bt->right = create_tree(value);
		return;
	}

	 if (bt->value > value)
	{
	
			insert_tree3(bt->left, value);
	

	}
	else if (bt->value < value)
	{
	

			insert_tree3(bt->right, value);
	

	}


}

// 非递归
b_tree * insert_tree4(b_tree * bt, int  value)
{

		
	b_tree * head = bt;
	std::cout << "please input new node value:" << value << "\t"<<bt <<endl;

run:
	if (!bt)
	{
		bt = create_tree(value);
		return head;
	}
	
	if (bt->value == value)
		return bt;
	else if (bt->value > value)
	{
		if (bt->left == NULL)
		{
			bt->left = create_tree(value);
			//return 	bt->left;
			
		}
		else
		{
			std::cout << "please input new node value left:" << value << "\t" << bt->left << endl;
		   // head =  insert_tree3(bt->left, value);

			bt = bt->left;
			goto run;
		}

	}
	else if (bt->value < value)
	{
		if (bt->right == NULL)
		{
			bt->right = create_tree(value);

			//	return bt->right;
			
		}
		else
		{
		
			std::cout << "please input new node value right:" << value << "\t" << bt->right << endl;
			//head= insert_tree3(bt->right, value);
			bt = bt->right;
			goto run;
		}

	}
	return head;

}



//same return 1,not return 0
int treeis_same(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)
		return -1;
	else if (p == NULL&&q == NULL)
		return 0;//?
	else
	{
		if (p->value != q->value)
			return -1;
		else {
			treeis_same(p->left, q->left);
			treeis_same(p->right, q->right);
		}
	}

}

//0 is iso ,other is not
int treeis_iso(tree * node)
{
	//null ,head is 1
	if (node == NULL)
		return 1;
	else if (node&&node->left == NULL &&node->right == NULL)
		return 1;
	tree * p = node;
	tree * q = node;
	tree * p1 = NULL;
	tree * q1 = NULL;
loop:
	p1 = p;
	q1 = q;
	p = p->left;
	q = q->right;
err:
	if (p == NULL&&q || q == NULL&&p)
		return -1;
	else
	{
		if (p == NULL&&q == NULL)
		{
			p = p1->right;
			q = q1->left;
			if (p == NULL&&q == NULL)
				return 0;
			else
				goto err;
		}
		else
		{
			if (p->value != q->value)
				return -1;
			else {
				goto loop;

			}
		}

	}
	
}

//地柜
int treeis_iso(tree * root)
{
	int dep = 0;
	if (root == NULL && dep == 0)
		return 1;
	else if (dep == 0&& root&&root->left == NULL &&root->right == NULL)
		return 1;
	
	if (root->left->value != root->right->value && dep == 0)
		return 0;
	if (1);
}


//min high
int min_high(tree * tr)
{
	
	if (tr == NULL)
	{
		cout << "null:" << endl;
		return 0;
	}

	if (tr->left == NULL&&tr->right == NULL)
	{
		cout << "child<<"<<tr->value << endl;
		return 1;
	}

	
	int left = min_high(tr->left);
	int right = min_high(tr->right);
	if(tr->left == NULL || tr->right == NULL)
		return left +right+ 1;
	if (left <=  right)
		return left + 1;
	else
		return right + 1;
	cout << tr->value << endl;
	
}

//cengci
void  trr(tree * root, int n)
{
	//static int  i = 1;
	//if (i == 1)
	//{
	//	cout <<"root:" <<root->value <<endl;
	//	if (root->left || (root->right))
	//	i = 0;
	//}
	//
	//if (i == 2)
	//{
	//	if (root->left)
	//	cout << "left:" << root->left->value << endl;
	//	if (root->right)
	//	cout << "right:" << root->right->value <<endl;
	//	i--;
	//	
	//}
	//if (i == n)
	//{
	//	cout << "leaf:" << root->value << endl;
	//	return;
	//}
	if (root == NULL || n<0)
	{
		cout << ";;;;;;;;;;;;;:" << endl;
		return ;
	}
	if (n == 0)//(!(root->left == NULL &&root->right == NULL) && n ==0)
	{
		//cout << "return again" << endl;
		std::cout << "root:" << root->value << endl;
		return ;
	}
	

	 trr(root->left, n-1);
	 trr(root->right, n-1);//n-2
}



void itor2(tree * root)
{

	int n = get_level(root);
	//int n_l;
	//int n_r;
	//if (root)
	//{
	//	std::cout << "root:" << root->value << endl;
	//	 n_l = get_level(root->left);
	//	 n_r = get_level(root->right);
	//}
	//std::cout << "left and right:" << n_l <<n_r<< endl;
	//if (n_l == n_r)
	//{
	//	trr(root, n_l + 1);
	//}

	//else if(n_l > n_r)
	//{
	//	 trr(root, n_r + 1);
	//	trr(root, n_l - n_r);
	//}
	//else
	//{
	//	trr(root, n_r + 1);
	//}

	std::cout << "roo000000000000t:" << root->value << endl;
	int i = 0;
	for (i = 1; i < n; i++)
	{
		trr(root, i);
	}
	

}
