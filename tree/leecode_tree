//地柜
void insert_tree_demo(b_tree * bt, int  value)
{
	int left = 0;
	int right = 0;
	std::cout << "please input new node value:" << value << endl;
	if (!bt)
	{
		bt = create_tree(value);
		return ;
	}
	if (bt->value == value)
		return ;
	else if (bt->value > value)
	{
		if (bt->left == NULL)
		{
			bt->left = create_tree(value);
			return ;
		}
		else
		{
			insert_tree3(bt->left, value);
		}

	}
	else if (bt->value < value)
	{
		if (bt->right == NULL)
		{
			bt->right = create_tree(value);
			return ;
		}
		else
		{
		
			 insert_tree3(bt->right, value);
		}

	}


}

//第二种地柜
void insert_tree_demo2(b_tree * bt, int  value)
{
	
	std::cout << "please input new node value:" << value << endl;
	if (!bt)
	{
		bt = create_tree(value);
		return;
	}
	if (bt->value == value)
		return;
	if (bt->value > value&& bt->left == NULL)
	{
		bt->left = create_tree(value);
		return;
	}
	if (bt->value < value&& bt->right == NULL)
	{
		bt->right = create_tree(value);
		return;
	}

	 if (bt->value > value)
	{
	
			insert_tree3(bt->left, value);
	

	}
	else if (bt->value < value)
	{
	

			insert_tree3(bt->right, value);
	

	}


}

// 非递归
b_tree * insert_tree4(b_tree * bt, int  value)
{

		
	b_tree * head = bt;
	std::cout << "please input new node value:" << value << "\t"<<bt <<endl;

run:
	if (!bt)
	{
		bt = create_tree(value);
		return head;
	}
	
	if (bt->value == value)
		return bt;
	else if (bt->value > value)
	{
		if (bt->left == NULL)
		{
			bt->left = create_tree(value);
			//return 	bt->left;
			
		}
		else
		{
			std::cout << "please input new node value left:" << value << "\t" << bt->left << endl;
		   // head =  insert_tree3(bt->left, value);

			bt = bt->left;
			goto run;
		}

	}
	else if (bt->value < value)
	{
		if (bt->right == NULL)
		{
			bt->right = create_tree(value);

			//	return bt->right;
			
		}
		else
		{
		
			std::cout << "please input new node value right:" << value << "\t" << bt->right << endl;
			//head= insert_tree3(bt->right, value);
			bt = bt->right;
			goto run;
		}

	}
	return head;

}



//same return 1,not return 0
int treeis_same(tree * p, tree * q)
{
	if (p == NULL&&q || q == NULL&&p)
		return -1;
	else if (p == NULL&&q == NULL)
		return 0;//?
	else
	{
		if (p->value != q->value)
			return -1;
		else {
			treeis_same(p->left, q->left);
			treeis_same(p->right, q->right);
		}
	}

}

//0 is iso ,other is not
int treeis_iso(tree * node)
{
	//null ,head is 1
	if (node == NULL)
		return 1;
	else if (node&&node->left == NULL &&node->right == NULL)
		return 1;
	tree * p = node;
	tree * q = node;
	tree * p1 = NULL;
	tree * q1 = NULL;
loop:
	p1 = p;
	q1 = q;
	p = p->left;
	q = q->right;
err:
	if (p == NULL&&q || q == NULL&&p)
		return -1;
	else
	{
		if (p == NULL&&q == NULL)
		{
			p = p1->right;
			q = q1->left;
			if (p == NULL&&q == NULL)
				return 0;
			else
				goto err;
		}
		else
		{
			if (p->value != q->value)
				return -1;
			else {
				goto loop;

			}
		}

	}
	
}

//地柜
int treeis_iso(tree * root)
{
	int dep = 0;
	if (root == NULL && dep == 0)
		return 1;
	else if (dep == 0&& root&&root->left == NULL &&root->right == NULL)
		return 1;
	
	if (root->left->value != root->right->value && dep == 0)
		return 0;
	if (1);
}
